///////////////////Вопрос 1: 

bool isEven(int value) {
  return value % 2 == 0;
}

//Плюсы:

    //Простота: Легко понять и написать.
    //Эффективность: Оператор % оптимизирован компилятором для быстрой работы.
    //Читаемость: Код хорошо читается и понятен другим разработчикам.

//Минусы:

    //Ограниченность: Не работает с типами данных, не поддерживающими оператор % (например, bool).
    //Потенциальная ошибка: Если значение value слишком велико, чтобы поместиться в тип int, может произойти переполнение, приводя к неверному результату.
	
bool isEvenBitwise(int value) {
  return (value & 1) == 0;
}

//Плюсы:

    //Универсальность: Работает с любыми типами данных, имеющими битовое представление.
    //Независимость от типа: Не зависит от разрядности типа int, что исключает переполнение.
    //Потенциальная оптимизация: Некоторые компиляторы могут оптимизировать эту реализацию еще больше, чем оператор %.

//Минусы:

    //Менее читаемая: Код может быть менее понятен для некоторых разработчиков, не знакомых с поразрядными операциями.
    //Незначительное снижение производительности: В некоторых случаях может быть немного медленнее, чем оператор %, из-за дополнительных битовых операций.
	


//В большинстве случаев мы рекомендуем использовать isEven(value), 
//так как она более проста, читаема и эффективна для большинства типов данных.

//Однако, если вам нужна универсальная функция, работающая с любыми типами данных, 
//или если вы работаете с очень большими числами, где возможно переполнение, то isEvenBitwise(value) может быть лучшим выбором.

///////////////////Вопрос 2: 

template <typename T>
class FixedSizeCircularBuffer {
private:
  T* buffer;
  int size;
  int head;
  int tail;

public:
  FixedSizeCircularBuffer(int size) {
    buffer = new T[size];
    this->size = size;
    head = 0;
    tail = 0;
  }

  // ... методы добавления, извлечения, проверки пустоты/полноты ...
};


//Плюсы:

    //Простота: Простая реализация, понятная и легкая в использовании.
    //Предсказуемая производительность: Время выполнения операций не зависит от количества элементов в буфере.

//Минусы:

    //Негибкость: Невозможно изменить размер буфера после его создания.
    //Неэффективное использование памяти: Если буфер используется не полностью, часть памяти будет пустовать.
	
template <typename T>
class DynamicCircularBuffer {
private:
  std::vector<T> buffer;
  int head;
  int tail;

public:
  DynamicCircularBuffer() {
    buffer.reserve(16); // Начальный размер буфера
    head = 0;
    tail = 0;
  }

  // ... методы добавления, извлечения, проверки пустоты/полноты ...

  void resize(int newSize) {
    if (newSize < capacity()) {
      throw std::runtime_error("Новый размер меньше текущего заполнения");
    }

    // Реализация логики изменения размера буфера
  }
};


//Плюсы:

    //Гибкость: Можно изменить размер буфера во время работы.
    //Эффективное использование памяти: Буфер использует только то количество памяти, которое необходимо для хранения данных.

//Минусы:

    //Сложность: Реализация динамического буфера более сложная, чем фиксированного.
    //Непредсказуемая производительность: Время выполнения операций может меняться в зависимости от количества элементов в буфере.
	
//**Если вам нужен простой и предсказуемый буфер с фиксированным размером, использу

///////////////////Вопрос 3: 

/*

В языке C/C++ не существует универсальной и самой быстрой функции сортировки для всех сценариев. Однако в большинстве случаев, особенно при работе со случайными или почти случайными данными и большими наборами данных, QuickSort считается лучшим выбором по скорости, основанной на тиках процессора. Вот почему:

    Средняя временная сложность: Средняя временная сложность QuickSort составляет O(n log n), что очень эффективно для больших массивов. Это означает, что количество операций, необходимых для сортировки массива, растет пропорционально логарифму количества элементов (n).
    Сортировка на месте: QuickSort сортирует данные in-place, то есть изменяет исходный массив без необходимости выделения дополнительной памяти. Это снижает затраты памяти по сравнению с алгоритмами, требующими дополнительного пространства.
    Оптимизированные реализации: Большинство реализаций сортировки в стандартной библиотеке C++ (например, std::sort) часто используют QuickSort за кулисами из-за его эффективности. Эти реализации сильно оптимизированы и используют специфические трюки компилятора для дальнейшего повышения скорости.

Здесь есть одно предостережение:

    Худший сценарий: В худшем случае временная сложность QuickSort может составлять O(n^2), что происходит в определенных ситуациях, когда данные уже отсортированы или почти отсортированы. Однако вероятность того, что это произойдет со случайными данными, очень мала.

Таким образом, QuickSort предлагает хороший баланс между средней производительностью и практичностью для большинства задач сортировки.

Вот пример, использующий стандартную библиотечную функцию сортировки (скорее всего, под капотом используется QuickSort):

*/

#include <iostream>
#include <algorithm>

void sortArray(int arr[], int n) {
  std::sort(arr, arr + n);
}
